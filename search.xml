<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GDB调试指南</title>
    <url>/2022/03/10/GDB%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<span id="more"></span> 

<h1 id="1-进程调试"><a href="#1-进程调试" class="headerlink" title="1.进程调试"></a>1.进程调试</h1><p>​        gdb -pid 1881(进程号)</p>
<p>​        b main.c:100(在main.c文件第一百行加断点)</p>
<p>​        c (执行监听断点)</p>
<p>​        bt(查看栈信息)</p>
<p>​        b(执行下一步)</p>
<p>​    </p>
<h1 id="2-coredump文件"><a href="#2-coredump文件" class="headerlink" title="2.coredump文件"></a>2.coredump文件</h1><p>​    <strong>打开coredump产生文件</strong></p>
<p>​        ulimit -c 1024</p>
<p>​        ulimit -a</p>
<p>​    调试coredump文件</p>
<p>​        gdb core-file /data/cipher_platform_ramdisk/rootfs/lic/core.9981</p>
<p>​    </p>
]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA 泛型介绍</title>
    <url>/2022/03/06/JAVA-%E6%B3%9B%E5%9E%8B%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<span id="more"></span> 

<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>​        集合里面存储了多个类型（某些情况下容器可能会存储多种类型的数据），如果数据量较多，转型的时候难免会出现异常，而这些都是无法在编译期得知的。而泛型一方面让我们只能往集合中添加一种类型的数据，同时可以让我们在编译期就发现这些错误，避免运行时异常的发生，提升代码的健壮性。</p>
<h2 id="Java泛型介绍"><a href="#Java泛型介绍" class="headerlink" title="Java泛型介绍"></a>Java泛型介绍</h2><p>​    下面我们来介绍Java泛型的相关内容，下面会介绍以下几个方面：</p>
<ul>
<li><p>Java泛型类</p>
</li>
<li><p>Java泛型方法</p>
</li>
<li><p>Java泛型接口</p>
</li>
<li><p>Java泛型擦除及其相关内容</p>
</li>
<li><p>Java泛型通配符</p>
<h3 id="Java泛型类"><a href="#Java泛型类" class="headerlink" title="Java泛型类"></a>Java泛型类</h3><p>​    类结构是面向对象中最基本的元素，如果我们的类需要有很好的扩展性，那么我们可以将其设置成泛型的。假设我们需要一个数据的包装类，通过传入不同类型的数据，可以存储相应类型的数据。我们看看这个简单的泛型类的设计：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataHolder</span>&lt;T&gt;&#123;</span><br><span class="line">    T item;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.item=t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>泛型类定义时只需要在类名后面加上类型参数即可，当然你也可以添加多个参数，类似于&lt;K,V&gt;,&lt;T,E,K&gt;等。这样我们就可以在类里面使用定义的类型参数。<br> 泛型类最常用的使用场景就是“元组”的使用。我们知道方法return返回值只能返回单个对象。如果我们定义一个泛型类，定义2个甚至3个类型参数，这样我们return对象的时候，构建这样一个“元组”数据，通过泛型传入多个对象，这样我们就可以一次性方法多个数据了</p>
<h3 id="Java泛型方法"><a href="#Java泛型方法" class="headerlink" title="Java泛型方法"></a>Java泛型方法</h3><p>​    前面我们介绍的泛型是作用于整个类的，现在我们来介绍泛型方法。泛型方法既可以存在于泛型类中，也可以存在于普通的类中。如果使用泛型方法可以解决问题，那么应该尽量使用泛型方法。下面我们通过例子来看一下泛型方法的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataHolder</span>&lt;T&gt;&#123;</span><br><span class="line">    T item;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    	<span class="built_in">this</span>.item=t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">PrinterInfo</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    	System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>shardingsphere 源码分析</title>
    <url>/2022/03/06/shardingsphere-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<span id="more"></span> 
]]></content>
  </entry>
  <entry>
    <title>移位运算</title>
    <url>/2022/05/18/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<span id="more"></span> 

<h3 id="1、一个32bit数据的位、字节读取操作"><a href="#1、一个32bit数据的位、字节读取操作" class="headerlink" title="1、一个32bit数据的位、字节读取操作"></a><strong>1、一个32bit数据的位、字节读取操作</strong></h3><p><strong>（1）获取单字节：</strong></p>
<p><img src="C:\Users\lic\AppData\Roaming\Typora\typora-user-images\image-20220518185005593.png" alt="image-20220518185005593"></p>
<p>示例：</p>
<p><img src="https://pic1.zhimg.com/80/v2-828faf67b00e1bdb7fecc724e22d5145_720w.jpg?source=1940ef5c" alt="img"></p>
<p>​    结果：</p>
<p>​    <img src="https://pic2.zhimg.com/80/v2-61d8fa5303cafb63d04d7f4b6a7f04b1_720w.jpg?source=1940ef5c" alt="img"></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
