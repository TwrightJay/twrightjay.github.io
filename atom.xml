<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TwrightJay的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-18T12:15:08.451Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>TwrightJay</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>移位运算</title>
    <link href="http://example.com/2022/05/18/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://example.com/2022/05/18/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2022-05-18T10:42:09.000Z</published>
    <updated>2022-05-18T12:15:08.451Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span> <h3 id="1、一个32bit数据的位、字节读取操作"><a href="#1、一个32bit数据的位、字节读取操作" class="headerlink" title="1、一个32bit数据的位、字节读取操作"></a><strong>1、一个32bit数据的位、字节读取操作</strong></h3><p><strong>（1）获取单字节：</strong></p><p><img src="https://raw.githubusercontent.com/wenjunlichao1231/image_host/main/202205181958703.png" alt="微信截图_20220518185629"></p><p>示例：</p><p><img src="https://pic1.zhimg.com/80/v2-828faf67b00e1bdb7fecc724e22d5145_720w.jpg?source=1940ef5c" alt="img"></p><p>​    结果：</p><p>​    <img src="https://pic2.zhimg.com/80/v2-61d8fa5303cafb63d04d7f4b6a7f04b1_720w.jpg?source=1940ef5c" alt="img"></p><p><strong>（2）获取某一位：</strong></p><p><img src="https://raw.githubusercontent.com/wenjunlichao1231/image_host/main/202205182006273.png" alt="微信截图_20220518200404"></p><p>示例：</p><p><img src="https://pic1.zhimg.com/80/v2-fcca555c2cbb62b6a10b3ec5dbd4b6b9_720w.jpg?source=1940ef5c" alt="img"></p><p>结果：</p><p><img src="https://pic3.zhimg.com/80/v2-b866068057297b15c1d5f0de303858db_720w.jpg?source=1940ef5c" alt="img"></p><h3 id="2、一个32bit数据的位、字节清零操作"><a href="#2、一个32bit数据的位、字节清零操作" class="headerlink" title="2、一个32bit数据的位、字节清零操作"></a><strong>2、一个32bit数据的位、字节清零操作</strong></h3><p><strong>（1）清零某个字节：</strong></p><p><img src="https://raw.githubusercontent.com/wenjunlichao1231/image_host/main/202205182007164.png" alt="微信截图_20220518200721"></p><p>示例：</p><p><img src="https://pic3.zhimg.com/80/v2-38c63aa6596f616e84ed77911f4d5743_720w.jpg?source=1940ef5c" alt="img"></p><p>结果：</p><p><img src="https://pic2.zhimg.com/80/v2-252b151196a826c8c1d23d22f20fbad1_720w.jpg?source=1940ef5c" alt="img"></p><p><strong>（2）清零某一位：</strong></p><p><img src="https://raw.githubusercontent.com/wenjunlichao1231/image_host/main/202205182008499.png" alt="微信截图_20220518200831"></p><p>示例：</p><p><img src="https://pic1.zhimg.com/80/v2-f0055826218634c6bb29cde53ec9f724_720w.jpg?source=1940ef5c" alt="img"></p><p>结果：</p><p><img src="https://pic3.zhimg.com/80/v2-fb45d2c856a88780ca5119ef5a413f4e_720w.jpg?source=1940ef5c" alt="img"></p><h3 id="3、一个32bit数据的位、字节置1操作"><a href="#3、一个32bit数据的位、字节置1操作" class="headerlink" title="3、一个32bit数据的位、字节置1操作"></a><strong>3、一个32bit数据的位、字节置1操作</strong></h3><p><strong>（1）置某个字节为1：</strong></p><p><img src="https://raw.githubusercontent.com/wenjunlichao1231/image_host/main/202205182009843.png" alt="微信截图_20220518200933"></p><p>示例：</p><p><img src="https://pic2.zhimg.com/80/v2-116d7b0ebb6cf5d5038c88906ced647e_720w.jpg?source=1940ef5c" alt="img"></p><p>结果：</p><p><img src="https://pic1.zhimg.com/80/v2-50784554281bbe99fe63335a49339265_720w.jpg?source=1940ef5c" alt="img"></p><p><strong>（2）置位某一位：</strong></p><p><img src="https://raw.githubusercontent.com/wenjunlichao1231/image_host/main/202205182010422.png" alt="微信截图_20220518201027"></p><p>示例：</p><p><img src="https://pic1.zhimg.com/80/v2-a1755837c51555d2966abc9d94097957_720w.jpg?source=1940ef5c" alt="img"></p><p>结果：</p><p><img src="https://pic2.zhimg.com/80/v2-3d1894f914522c0cd3578987e2bbd267_720w.jpg?source=1940ef5c" alt="img"></p><h3 id="4、判断某一位或某几位连续位的值"><a href="#4、判断某一位或某几位连续位的值" class="headerlink" title="4、判断某一位或某几位连续位的值"></a><strong>4、判断某一位或某几位连续位的值</strong></h3><p><strong>（1）判断某一位的值</strong></p><p>举例说明：判断0x68第三位的值</p><p><img src="https://pica.zhimg.com/80/v2-f26112bb7b338cef585215259aad4fb5_720w.jpg?source=1940ef5c" alt="img"></p><p>结果：</p><p><img src="https://pic2.zhimg.com/80/v2-68f711275c7b92c0eb6dcf1eed6fa8c7_720w.jpg?source=1940ef5c" alt="img"></p><p>也就是说，要判断第几位的值if里就左移几位，在嵌入式编程里，可通过这样的方式来判断寄存器的状态位是否被置位</p><p><strong>（2）判断某几位连续位的值</strong></p><p><img src="https://raw.githubusercontent.com/wenjunlichao1231/image_host/main/202205182014965.png" alt="微信截图_20220518201424"></p><p>示例：</p><p><img src="https://pic3.zhimg.com/80/v2-4394f22e1295fadece437b25d6f28ca6_720w.jpg?source=1940ef5c" alt="img"></p><p>结果：</p><p><img src="https://pic1.zhimg.com/80/v2-3100c6675b51b86fdf913753fb41b84b_720w.jpg?source=1940ef5c" alt="img"></p>]]></content>
    
    
    <summary type="html">计算机中的数在内存中都是以二进制形式进行存储的，用位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高，在程序中尽量使用位运算进行操作，这会大大提高程序的性能</summary>
    
    
    
    <category term="C/C++" scheme="http://example.com/categories/C-C/"/>
    
    
    <category term="C/C++" scheme="http://example.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>GDB调试指南</title>
    <link href="http://example.com/2022/03/10/GDB%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>http://example.com/2022/03/10/GDB%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/</id>
    <published>2022-03-10T01:46:16.000Z</published>
    <updated>2022-05-16T09:18:41.551Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span> <h1 id="1-进程调试"><a href="#1-进程调试" class="headerlink" title="1.进程调试"></a>1.进程调试</h1><p>​        gdb -pid 1881(进程号)</p><p>​        b main.c:100(在main.c文件第一百行加断点)</p><p>​        c (执行监听断点)</p><p>​        bt(查看栈信息)</p><p>​        b(执行下一步)</p><p>​    </p><h1 id="2-coredump文件"><a href="#2-coredump文件" class="headerlink" title="2.coredump文件"></a>2.coredump文件</h1><p>​    <strong>打开coredump产生文件</strong></p><p>​        ulimit -c 1024</p><p>​        ulimit -a</p><p>​    调试coredump文件</p><p>​        gdb core-file /data/cipher_platform_ramdisk/rootfs/lic/core.9981</p><p>​    </p>]]></content>
    
    
    <summary type="html">GDB调试常用指令</summary>
    
    
    
    <category term="c/c++" scheme="http://example.com/categories/c-c/"/>
    
    
    <category term="c/c++" scheme="http://example.com/tags/c-c/"/>
    
  </entry>
  
  <entry>
    <title>shardingsphere 源码分析</title>
    <link href="http://example.com/2022/03/06/shardingsphere-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2022/03/06/shardingsphere-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-03-06T06:58:05.000Z</published>
    <updated>2022-03-06T07:00:59.510Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span> ]]></content>
    
    
    <summary type="html">点击阅读前文前, 首页能看到的文章的简短描述</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>JAVA 泛型介绍</title>
    <link href="http://example.com/2022/03/06/JAVA-%E6%B3%9B%E5%9E%8B%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2022/03/06/JAVA-%E6%B3%9B%E5%9E%8B%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-03-06T06:52:20.000Z</published>
    <updated>2022-03-06T06:57:28.239Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span> <h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>​        集合里面存储了多个类型（某些情况下容器可能会存储多种类型的数据），如果数据量较多，转型的时候难免会出现异常，而这些都是无法在编译期得知的。而泛型一方面让我们只能往集合中添加一种类型的数据，同时可以让我们在编译期就发现这些错误，避免运行时异常的发生，提升代码的健壮性。</p><h2 id="Java泛型介绍"><a href="#Java泛型介绍" class="headerlink" title="Java泛型介绍"></a>Java泛型介绍</h2><p>​    下面我们来介绍Java泛型的相关内容，下面会介绍以下几个方面：</p><ul><li><p>Java泛型类</p></li><li><p>Java泛型方法</p></li><li><p>Java泛型接口</p></li><li><p>Java泛型擦除及其相关内容</p></li><li><p>Java泛型通配符</p><h3 id="Java泛型类"><a href="#Java泛型类" class="headerlink" title="Java泛型类"></a>Java泛型类</h3><p>​    类结构是面向对象中最基本的元素，如果我们的类需要有很好的扩展性，那么我们可以将其设置成泛型的。假设我们需要一个数据的包装类，通过传入不同类型的数据，可以存储相应类型的数据。我们看看这个简单的泛型类的设计：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataHolder</span>&lt;T&gt;&#123;</span><br><span class="line">    T item;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.item=t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>泛型类定义时只需要在类名后面加上类型参数即可，当然你也可以添加多个参数，类似于&lt;K,V&gt;,&lt;T,E,K&gt;等。这样我们就可以在类里面使用定义的类型参数。<br> 泛型类最常用的使用场景就是“元组”的使用。我们知道方法return返回值只能返回单个对象。如果我们定义一个泛型类，定义2个甚至3个类型参数，这样我们return对象的时候，构建这样一个“元组”数据，通过泛型传入多个对象，这样我们就可以一次性方法多个数据了</p><h3 id="Java泛型方法"><a href="#Java泛型方法" class="headerlink" title="Java泛型方法"></a>Java泛型方法</h3><p>​    前面我们介绍的泛型是作用于整个类的，现在我们来介绍泛型方法。泛型方法既可以存在于泛型类中，也可以存在于普通的类中。如果使用泛型方法可以解决问题，那么应该尽量使用泛型方法。下面我们通过例子来看一下泛型方法的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataHolder</span>&lt;T&gt;&#123;</span><br><span class="line">    T item;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.item=t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.item;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 泛型方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">PrinterInfo</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">集合里面存储了多个类型（某些情况下容器可能会存储多种类型的数据），如果数据量较多，转型的时候难免会出现异常，而这些都是无法在编译期得知的。而泛型一方面让我们只能往集合中添加一种类型的数据，同时可以让我们在编译期就发现这些错误，避免运行时异常的发生，提升代码的健壮性</summary>
    
    
    
    
  </entry>
  
</feed>
