<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TwrightJay的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-11-01T06:55:05.460Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>TwrightJay</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>移位运算</title>
    <link href="http://example.com/2022/05/18/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://example.com/2022/05/18/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2022-05-18T10:42:09.000Z</published>
    <updated>2022-11-01T06:55:05.460Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span> <h3 id="1、一个32bit数据的位、字节读取操作"><a href="#1、一个32bit数据的位、字节读取操作" class="headerlink" title="1、一个32bit数据的位、字节读取操作"></a><strong>1、一个32bit数据的位、字节读取操作</strong></h3><p><strong>（1）获取单字节：</strong></p><p><img src="https://raw.githubusercontent.com/wenjunlichao1231/image_host/main/202205181958703.png" alt="微信截图_20220518185629"></p><p>示例：</p><p><img src="https://raw.githubusercontent.com/TwrightJay/twrightjay.github.io/main/v2-828faf67b00e1bdb7fecc724e22d5145_720w.jpg" alt="img"></p><p>​    结果：</p><p>​    <img src="https://pic2.zhimg.com/80/v2-61d8fa5303cafb63d04d7f4b6a7f04b1_720w.jpg?source=1940ef5c" alt="img">    </p><p><strong>（2）获取某一位：</strong></p><p><img src="https://raw.githubusercontent.com/wenjunlichao1231/image_host/main/202205182006273.png" alt="微信截图_20220518200404"></p><p>示例：</p><p><img src="https://pic1.zhimg.com/80/v2-fcca555c2cbb62b6a10b3ec5dbd4b6b9_720w.jpg?source=1940ef5c" alt="img"></p><p>结果：</p><p><img src="https://pic3.zhimg.com/80/v2-b866068057297b15c1d5f0de303858db_720w.jpg?source=1940ef5c" alt="img"></p><h3 id="2、一个32bit数据的位、字节清零操作"><a href="#2、一个32bit数据的位、字节清零操作" class="headerlink" title="2、一个32bit数据的位、字节清零操作"></a><strong>2、一个32bit数据的位、字节清零操作</strong></h3><p><strong>（1）清零某个字节：</strong></p><p><img src="https://raw.githubusercontent.com/wenjunlichao1231/image_host/main/202205182007164.png" alt="微信截图_20220518200721"></p><p>示例：</p><p><img src="https://pic3.zhimg.com/80/v2-38c63aa6596f616e84ed77911f4d5743_720w.jpg?source=1940ef5c" alt="img"></p><p>结果：</p><p><img src="https://pic2.zhimg.com/80/v2-252b151196a826c8c1d23d22f20fbad1_720w.jpg?source=1940ef5c" alt="img"></p><p><strong>（2）清零某一位：</strong></p><p><img src="https://raw.githubusercontent.com/wenjunlichao1231/image_host/main/202205182008499.png" alt="微信截图_20220518200831"></p><p>示例：</p><p><img src="https://pic1.zhimg.com/80/v2-f0055826218634c6bb29cde53ec9f724_720w.jpg?source=1940ef5c" alt="img"></p><p>结果：</p><p><img src="https://pic3.zhimg.com/80/v2-fb45d2c856a88780ca5119ef5a413f4e_720w.jpg?source=1940ef5c" alt="img"></p><h3 id="3、一个32bit数据的位、字节置1操作"><a href="#3、一个32bit数据的位、字节置1操作" class="headerlink" title="3、一个32bit数据的位、字节置1操作"></a><strong>3、一个32bit数据的位、字节置1操作</strong></h3><p><strong>（1）置某个字节为1：</strong></p><p><img src="https://raw.githubusercontent.com/wenjunlichao1231/image_host/main/202205182009843.png" alt="微信截图_20220518200933"></p><p>示例：</p><p><img src="https://pic2.zhimg.com/80/v2-116d7b0ebb6cf5d5038c88906ced647e_720w.jpg?source=1940ef5c" alt="img"></p><p>结果：</p><p><img src="https://pic1.zhimg.com/80/v2-50784554281bbe99fe63335a49339265_720w.jpg?source=1940ef5c" alt="img"></p><p><strong>（2）置位某一位：</strong></p><p><img src="https://raw.githubusercontent.com/wenjunlichao1231/image_host/main/202205182010422.png" alt="微信截图_20220518201027"></p><p>示例：</p><p><img src="https://pic1.zhimg.com/80/v2-a1755837c51555d2966abc9d94097957_720w.jpg?source=1940ef5c" alt="img"></p><p>结果：</p><p><img src="https://pic2.zhimg.com/80/v2-3d1894f914522c0cd3578987e2bbd267_720w.jpg?source=1940ef5c" alt="img"></p><h3 id="4、判断某一位或某几位连续位的值"><a href="#4、判断某一位或某几位连续位的值" class="headerlink" title="4、判断某一位或某几位连续位的值"></a><strong>4、判断某一位或某几位连续位的值</strong></h3><p><strong>（1）判断某一位的值</strong></p><p>举例说明：判断0x68第三位的值</p><p><img src="https://pica.zhimg.com/80/v2-f26112bb7b338cef585215259aad4fb5_720w.jpg?source=1940ef5c" alt="img"></p><p>结果：</p><p><img src="https://pic2.zhimg.com/80/v2-68f711275c7b92c0eb6dcf1eed6fa8c7_720w.jpg?source=1940ef5c" alt="img"></p><p>也就是说，要判断第几位的值if里就左移几位，在嵌入式编程里，可通过这样的方式来判断寄存器的状态位是否被置位</p><p><strong>（2）判断某几位连续位的值</strong></p><p><img src="https://raw.githubusercontent.com/wenjunlichao1231/image_host/main/202205182014965.png" alt="微信截图_20220518201424"></p><p>示例：</p><p><img src="https://pic3.zhimg.com/80/v2-4394f22e1295fadece437b25d6f28ca6_720w.jpg?source=1940ef5c" alt="img"></p><p>结果：</p><p><img src="https://raw.githubusercontent.com/wenjunlichao1231/image_host/main/202208021059360.jpg" alt="v2-3100c6675b51b86fdf913753fb41b84b_720w"></p><p><img src="https://raw.githubusercontent.com/wenjunlichao1231/image_host/main/202208071035292.png" alt="image-20220807103528006"></p>]]></content>
    
    
    <summary type="html">计算机中的数在内存中都是以二进制形式进行存储的，用位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高，在程序中尽量使用位运算进行操作，这会大大提高程序的性能</summary>
    
    
    
    <category term="C/C++" scheme="http://example.com/categories/C-C/"/>
    
    
    <category term="C/C++" scheme="http://example.com/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>GDB调试指南</title>
    <link href="http://example.com/2022/03/10/GDB%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/"/>
    <id>http://example.com/2022/03/10/GDB%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/</id>
    <published>2022-03-10T01:46:16.000Z</published>
    <updated>2022-11-01T07:01:24.010Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span> <h1 id="1-进程调试"><a href="#1-进程调试" class="headerlink" title="1. 进程调试"></a>1. 进程调试</h1><p>​        gdb -pid 1881(进程号)</p><p>​        b main.c:100(在main.c文件第一百行加断点)</p><p>​        c (执行监听断点)</p><p>​        bt(查看栈信息)</p><p>​        b(执行下一步)</p><p>​    </p><h1 id="2-coredump文件"><a href="#2-coredump文件" class="headerlink" title="2. coredump文件"></a>2. coredump文件</h1><p>​    <strong>打开coredump产生文件</strong></p><p>​        ulimit -c 1024</p><p>​        ulimit -a</p><p>​    调试coredump文件</p><p>​        gdb core-file /data/cipher_platform_ramdisk/rootfs/lic/core.9981</p><h1 id="3-已运行程序调试"><a href="#3-已运行程序调试" class="headerlink" title="3. 已运行程序调试"></a>3. 已运行程序调试</h1><p>​    ps命令找到进程id：</p><p>​        <code>$ ps -ef|grep 进程名</code></p><p>​    attach进程id</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gdb</span><br><span class="line">(gdb) attach 20829</span><br></pre></td></tr></table></figure><p>​    直接调试相关进程ＩＤ</p><p>​    <code>gdb hello 20829  </code></p><p>​    或者</p><p>​    <code>gdb hello --pid 20829</code></p><h3 id="已运行程序没有调试信息"><a href="#已运行程序没有调试信息" class="headerlink" title="已运行程序没有调试信息"></a><strong>已运行程序没有调试信息</strong></h3><p>​    为了节省磁盘空间，已经运行的程序通常没有调试信息。但如果又不能停止当前程序重新启动调试，那怎么办呢？还有办法，那就是同样的代码，再编译出一个带调试信息的版本。然后使用和前面提到的方式操作。对于attach方式，在attach之前，使用file命令即可：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gdb</span><br><span class="line">(gdb) file hello</span><br><span class="line">Reading symbols from hello...done.</span><br><span class="line">(gdb)attach 20829</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/TwrightJay/twrightjay.github.io/main/202211011501645.jpg"></p>]]></content>
    
    
    <summary type="html">GDB调试常用指令</summary>
    
    
    
    <category term="c/c++" scheme="http://example.com/categories/c-c/"/>
    
    
    <category term="c/c++" scheme="http://example.com/tags/c-c/"/>
    
  </entry>
  
</feed>
